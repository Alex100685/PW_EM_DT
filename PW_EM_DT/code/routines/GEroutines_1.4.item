package routines;

/*
 */
public class GEroutines {
	 static {
			System.setProperty("TalendJob.log",
					"GEroutines.log");
		}
private static org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(GEroutines.class);
  private static Boolean debugModeOn = true;
  private static java.util.Map<String, String> 	TYPE_CONEVERsION_MAP;
  private static java.util.Map<String, String> 	TYPE_CONEVERsION_MAP_HDFS;
  private static java.util.ArrayList<String> 	RESERVED_KEYWORDS;
  private static java.util.Map<String, String> 	TYPE_CONVERSION_MAP;
  private static java.util.Map<String, String> 	TYPE_CONVERSION_MAP_ORA;
  private static java.util.Map<String, String> 	TYPE_CONVERSION_MAP_HIVE;
  private static java.util.Map<String, Integer> SYSTEM_TYPE_MAP;
  static
  {	  
    TYPE_CONEVERsION_MAP = new java.util.HashMap<String, String>();
    
    TYPE_CONVERSION_MAP = new java.util.HashMap<String, String>();
    TYPE_CONVERSION_MAP_ORA = new java.util.HashMap<String, String>();
    TYPE_CONVERSION_MAP_HIVE = new java.util.HashMap<String, String>();
    
    /*character varying*/
    TYPE_CONVERSION_MAP.put(  "int unsigned" 					, "numeric" ); 
	TYPE_CONVERSION_MAP_ORA.put(  "int unsigned"                , "number" );
    TYPE_CONVERSION_MAP_HIVE.put( "int unsigned"                , "decimal" );
	
    TYPE_CONEVERsION_MAP.put(  "varchar2"						, "character varying" );
    TYPE_CONEVERsION_MAP.put(  "nvarchar2"						, "character varying" );
    TYPE_CONEVERsION_MAP.put(  "varchar"						, "character varying" );
    TYPE_CONEVERsION_MAP.put(  "nvarchar"						, "character varying" );
    TYPE_CONEVERsION_MAP.put(  "uniqueidentifier"				, "character varying" );
    TYPE_CONEVERsION_MAP.put(  "text"							, "character varying" );
    TYPE_CONEVERsION_MAP.put(  "ntext"							, "character varying" );
    TYPE_CONEVERsION_MAP.put(  "char varying"					, "character varying" );
    TYPE_CONEVERsION_MAP.put(  "character varying"				, "character varying" );
    TYPE_CONEVERsION_MAP.put(  "anydata"						, "character varying" );
    TYPE_CONEVERsION_MAP.put(  "sys.anydata"					, "character varying" );
    /** TODO
    TYPE_CONEVERsION_MAP.put(  "system.xnp_message_type"		, "character varying" );*/
    TYPE_CONEVERsION_MAP.put(  "mdsys.sdo_geometry"				, "polygon" );
    /* bytea */  
    TYPE_CONEVERsION_MAP.put(  "blob"							, "bytea" );
    TYPE_CONEVERsION_MAP.put(  "raw"							, "bytea" );
    TYPE_CONEVERsION_MAP.put(  "long raw"						, "bytea" );
    TYPE_CONEVERsION_MAP.put(  "enum"							, "bytea" );
    TYPE_CONEVERsION_MAP.put(  "set"							, "bytea" );
    TYPE_CONEVERsION_MAP.put(  "char() for bit data"			, "bytea" );
    TYPE_CONEVERsION_MAP.put(  "VARCHAR () FOR BIT DATA"		, "bytea" );
    TYPE_CONEVERsION_MAP.put(  "varbinary"						, "bytea" );
    TYPE_CONEVERsION_MAP.put(  "longvarbinary"					, "bytea" );
    TYPE_CONEVERsION_MAP.put(  "jsonb"							, "bytea" );
    /* text */  
    TYPE_CONEVERsION_MAP.put(  "urowid"							, "text" );
    TYPE_CONEVERsION_MAP.put(  "rowid"							, "text" );
    TYPE_CONEVERsION_MAP.put(  "long"							, "text" );
    TYPE_CONEVERsION_MAP.put(  "clob"							, "text" );
    TYPE_CONEVERsION_MAP.put(  "char large object"				, "text" );
    TYPE_CONEVERsION_MAP.put(  "character large object"			, "text" );
    TYPE_CONEVERsION_MAP.put(  "json"							, "text" );
    /* date */  
    TYPE_CONEVERsION_MAP.put(  "ansidate"						, "date" );
    TYPE_CONEVERsION_MAP.put(  "date"							, "date" );
    TYPE_CONEVERsION_MAP.put(  "datetime"						, "timestamp without time zone" );
    TYPE_CONEVERsION_MAP.put(  "datetime2"						, "timestamp without time zone" );
    /* numeric */  
    TYPE_CONEVERsION_MAP.put(  "integer"						, "numeric" );
    TYPE_CONEVERsION_MAP.put(  "integer1"						, "numeric" );
    TYPE_CONEVERsION_MAP.put(  "small integer"					, "numeric" );
    TYPE_CONEVERsION_MAP.put(  "int"							, "numeric" );
    TYPE_CONEVERsION_MAP.put(  "int1"							, "numeric" );
    TYPE_CONEVERsION_MAP.put(  "int2"							, "numeric" );
    TYPE_CONEVERsION_MAP.put(  "int4"							, "numeric" );
    TYPE_CONEVERsION_MAP.put(  "int8"							, "numeric" );
    TYPE_CONEVERsION_MAP.put(  "smallint"						, "numeric" );
    TYPE_CONEVERsION_MAP.put(  "byteint"						, "numeric" );
    TYPE_CONEVERsION_MAP.put(  "smallint unsigned"				, "numeric" );
    TYPE_CONEVERsION_MAP.put(  "tinyint"						, "numeric" );
    TYPE_CONEVERsION_MAP.put(  "mediumint"						, "numeric" );
    TYPE_CONEVERsION_MAP.put(  "bigint"							, "numeric" );
    TYPE_CONEVERsION_MAP.put(  "decimal"						, "numeric" );
    TYPE_CONEVERsION_MAP.put(  "large integer"					, "numeric" );
    TYPE_CONEVERsION_MAP.put(  "big integer"					, "numeric" );
    TYPE_CONEVERsION_MAP.put(  "single-precision floating-point", "double precision" );
    TYPE_CONEVERsION_MAP.put(  "double-precision floating-point", "double precision" );
    TYPE_CONEVERsION_MAP.put(  "numeric"						, "numeric" );
    TYPE_CONEVERsION_MAP.put(  "number"							, "numeric" );
    TYPE_CONEVERsION_MAP.put(  "float"							, "double precision" );
    TYPE_CONEVERsION_MAP.put(  "float4"							, "double precision" );  
    TYPE_CONEVERsION_MAP.put(  "double"							, "double precision" );
    TYPE_CONEVERsION_MAP.put(  "decimal"						, "numeric" );
    TYPE_CONEVERsION_MAP.put(  "real"							, "double precision" ); 
    
    /* character types */
    TYPE_CONEVERsION_MAP.put(  "char"							, "character" );
    TYPE_CONEVERsION_MAP.put(  "nchar"							, "character" );
    /* timestamps with timezone*/
    TYPE_CONEVERsION_MAP.put(  "timestamp with time zone"		, "timestamp with time zone" );
    TYPE_CONEVERsION_MAP.put(  "timestamptz"					, "timestamp with time zone" );
    TYPE_CONEVERsION_MAP.put(  "timestamp(6)"					, "date");
    TYPE_CONEVERsION_MAP.put(  "timestampltz"					, "date");
    /* timestamps withOUT timezone */
    TYPE_CONEVERsION_MAP.put(  "time"							, "time" );
    TYPE_CONEVERsION_MAP.put(  "timestamp without time zone"	, "timestamp without time zone" );
    TYPE_CONEVERsION_MAP.put(  "timestamp"						, "timestamp without time zone" );
    
    // SQL SERVER TYPES
    TYPE_CONEVERsION_MAP.put(  "smalldatetime"					, "timestamp without time zone" );
    TYPE_CONEVERsION_MAP.put(  "int identity"					, "serial" );
    TYPE_CONEVERsION_MAP.put(  "image"       					, "bytea" );
    TYPE_CONEVERsION_MAP.put(  "binary"       					, "bytea" );
    TYPE_CONEVERsION_MAP.put(  "money"       					, "numeric" );
    
    //Bools everywhere and nowhere
    TYPE_CONEVERsION_MAP.put(  "bit"							, "boolean" );
    TYPE_CONEVERsION_MAP.put(  "bool"							, "boolean" );
    TYPE_CONEVERsION_MAP.put(  "boolean"						, "boolean" );
    
    
    //S  A  P
    //                    SAP TYPE    SQL TYPE                 Java type
    TYPE_CONEVERsION_MAP.put("P" , "numeric"			); // "id_Double");
    TYPE_CONEVERsION_MAP.put("C" , "character varying"	); // "id_String");
    TYPE_CONEVERsION_MAP.put("D" , "date"				); // "id_Date");
    TYPE_CONEVERsION_MAP.put("F" , "numeric"			); // "id_Double");
    TYPE_CONEVERsION_MAP.put("I" , "numeric"			); // "id_Integer");
    TYPE_CONEVERsION_MAP.put("b" , "numeric"			); // "id_Double");
    TYPE_CONEVERsION_MAP.put("s" , "numeric"			); // "id_Double");
    TYPE_CONEVERsION_MAP.put("N" , "character varying"	); // "id_String");
    TYPE_CONEVERsION_MAP.put("S" , "character varying"	); // "id_String");
    TYPE_CONEVERsION_MAP.put("T" , "time"				); // "id_String");
    TYPE_CONEVERsION_MAP.put("X" , "character varying"	); // "id_String");
    TYPE_CONEVERsION_MAP.put("g" , "text"				); // "id_String"); ABAP Type ‘G’: Variable length character string
    TYPE_CONEVERsION_MAP.put("y" , "text"				); // "id_String"); ABAP Type ‘Y’: Variable length byte array

    TYPE_CONEVERsION_MAP_HDFS = new java.util.HashMap<String, String>();
    /*character varying*/
    TYPE_CONEVERsION_MAP_HDFS.put(  "varchar2"						, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "nvarchar2"						, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "varchar"						, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "nvarchar"						, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "text"							, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "ntext"							, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "char varying"					, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "character varying"				, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "anydata"						, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "sys.anydata"					, "STRING" );
    /** TODO
    TYPE_CONEVERsION_MAP_HDFS.put(  "system.xnp_message_type"		, "STRING" );*/
    TYPE_CONEVERsION_MAP_HDFS.put(  "mdsys.sdo_geometry"				, "STRING" );
    /* bytea */  
    TYPE_CONEVERsION_MAP_HDFS.put(  "blob"							, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "raw"							, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "long raw"						, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "enum"							, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "set"							, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "char() for bit data"			, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "VARCHAR () FOR BIT DATA"		, "STRING" );
    /* text */  
    TYPE_CONEVERsION_MAP_HDFS.put(  "urowid"							, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "rowid"							, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "long"							, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "clob"							, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "char large object"				, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "character large object"			, "STRING" );
    /* date */  
    TYPE_CONEVERsION_MAP_HDFS.put(  "ansidate"						, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "date"							, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "datetime"						, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "datetime2"						, "STRING" );
    /* numeric */  
    TYPE_CONEVERsION_MAP_HDFS.put(  "integer"						, "BIGINT" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "integer1"						, "BIGINT" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "small integer"					, "BIGINT" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "int"							, "BIGINT" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "int1"							, "BIGINT" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "int2"							, "BIGINT" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "int4"							, "BIGINT" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "int8"							, "BIGINT" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "smallint"						, "BIGINT" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "smallint unsigned"				, "BIGINT" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "tinyint"						, "BIGINT" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "mediumint"						, "BIGINT" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "bigint"							, "BIGINT" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "decimal"						, "BIGINT" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "large integer"					, "BIGINT" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "big integer"					, "BIGINT" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "single-precision floating-point", "double" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "double-precision floating-point", "double" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "numeric"						, "BIGINT" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "number"							, "BIGINT" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "float"							, "double" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "float4"							, "float" );  
    TYPE_CONEVERsION_MAP_HDFS.put(  "double"							, "double" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "decimal"						, "BIGINT" );
   
    
    /* character types */
    TYPE_CONEVERsION_MAP_HDFS.put(  "char"							, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "nchar"							, "STRING" );
    /* timestamps with timezone*/
    TYPE_CONEVERsION_MAP_HDFS.put(  "timestamp with time zone"		, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "timestamptz"					, "STRING" );
    
    /* timestamps withOUT timezone */
    TYPE_CONEVERsION_MAP_HDFS.put(  "time"							, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "timestamp without time zone"	, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "timestamp"						, "STRING" );
    
    // SQL SERVER TYPES
    TYPE_CONEVERsION_MAP_HDFS.put(  "smalldatetime"					, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "int identity"					, "INT" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "image"       					, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "binary"       					, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "money"       					, "BIGINT" );
    
    //Bools everywhere and nowhere
    TYPE_CONEVERsION_MAP_HDFS.put(  "bit"							, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "bool"							, "STRING" );
    TYPE_CONEVERsION_MAP_HDFS.put(  "boolean"						, "STRING" );
    
    
    //S  A  P
    //                    SAP TYPE    SQL TYPE                 Java type
    TYPE_CONEVERsION_MAP_HDFS.put("P" , "BIGINT"			); // "id_Double");
    TYPE_CONEVERsION_MAP_HDFS.put("C" , "STRING"	); // "id_String");
    TYPE_CONEVERsION_MAP_HDFS.put("D" , "STRING"				); // "id_Date");
    TYPE_CONEVERsION_MAP_HDFS.put("F" , "BIGINT"			); // "id_Double");
    TYPE_CONEVERsION_MAP_HDFS.put("I" , "BIGINT"			); // "id_Integer");
    TYPE_CONEVERsION_MAP_HDFS.put("b" , "BIGINT"			); // "id_Double");
    TYPE_CONEVERsION_MAP_HDFS.put("s" , "BIGINT"			); // "id_Double");
    TYPE_CONEVERsION_MAP_HDFS.put("N" , "STRING"	); // "id_String");
    TYPE_CONEVERsION_MAP_HDFS.put("S" , "STRING"	); // "id_String");
    TYPE_CONEVERsION_MAP_HDFS.put("T" , "STRING"				); // "id_String");
    TYPE_CONEVERsION_MAP_HDFS.put("X" , "STRING"	); // "id_String");
    TYPE_CONEVERsION_MAP_HDFS.put("g" , "STRING"				); // "id_String"); ABAP Type ‘G’: Variable length character string
    TYPE_CONEVERsION_MAP_HDFS.put("y" , "STRING"				); // "id_String"); ABAP Type ‘Y’: Variable length byte array
    
    /* code added from GEroutine5.4 version to fix mapToTargetTypes method*/
    
    /*postgres/universal*/
    TYPE_CONVERSION_MAP.put(  "bpchar"							, "character varying" );
    TYPE_CONVERSION_MAP.put(  "varchar2"						, "character varying" );
    TYPE_CONVERSION_MAP.put(  "nvarchar2"						, "character varying" );
    TYPE_CONVERSION_MAP.put(  "varchar"							, "character varying" );
    TYPE_CONVERSION_MAP.put(  "wvarchar"						, "character varying" );
    TYPE_CONVERSION_MAP.put(  "nvarchar"						, "character varying" );
    TYPE_CONVERSION_MAP.put(  "text"							, "text" );
    TYPE_CONVERSION_MAP.put(  "ntext"							, "text" );
    TYPE_CONVERSION_MAP.put(  "char varying"					, "character varying" );
    TYPE_CONVERSION_MAP.put(  "character varying"				, "character varying" );
    TYPE_CONVERSION_MAP.put(  "anydata"							, "character varying" );
    TYPE_CONVERSION_MAP.put(  "sys.anydata"						, "character varying" );
     TYPE_CONVERSION_MAP.put(  "system.xnp_message_type"		, "character varying" );
	 /*postgres/universal*/
    TYPE_CONVERSION_MAP.put(  "blob"							, "bytea" );
    TYPE_CONVERSION_MAP.put(  "bytea"							, "bytea" );
    TYPE_CONVERSION_MAP.put(  "raw"								, "bytea" );
    TYPE_CONVERSION_MAP.put(  "long raw"						, "bytea" );
    TYPE_CONVERSION_MAP.put(  "enum"							, "bytea" );
    TYPE_CONVERSION_MAP.put(  "set"								, "bytea" );
    TYPE_CONVERSION_MAP.put(  "char() for bit data"				, "bytea" );
    TYPE_CONVERSION_MAP.put(  "VARCHAR () FOR BIT DATA"			, "bytea" );
    TYPE_CONVERSION_MAP.put(  "varbinary"						, "bytea" );
    TYPE_CONVERSION_MAP.put(  "longvarbinary"						, "bytea" );
/*postgres/universal*/
    
    TYPE_CONVERSION_MAP.put(  "longvarchar"						, "text" );
    TYPE_CONVERSION_MAP.put(  "urowid"							, "text" );
    TYPE_CONVERSION_MAP.put(  "rowid"							, "varchar" );
    TYPE_CONVERSION_MAP.put(  "long"							, "text/*long*/" );
    TYPE_CONVERSION_MAP.put(  "clob"							, "text" );
    TYPE_CONVERSION_MAP.put(  "char large object"				, "text" );
    TYPE_CONVERSION_MAP.put(  "character large object"			, "text" );
    TYPE_CONVERSION_MAP.put(  "text"							, "text" );
 TYPE_CONVERSION_MAP.put(  "ansidate"						, "timestamp without time zone" );
    TYPE_CONVERSION_MAP.put(  "date"							, "timestamp without time zone" );
    TYPE_CONVERSION_MAP.put(  "datetime"						, "timestamp without time zone" );
    TYPE_CONVERSION_MAP.put(  "datetime2"						, "timestamp without time zone" );
    TYPE_CONVERSION_MAP.put(  "timestamp"						, "timestamp without time zone" );
    TYPE_CONVERSION_MAP.put(  "timestamp with time zone"		, "timestamp with time zone" );
    TYPE_CONVERSION_MAP.put(  "timestamptz"						, "timestamp with time zone" );
    TYPE_CONVERSION_MAP.put(  "time"							, "time" );
    TYPE_CONVERSION_MAP.put(  "timestamp without time zone"		, "timestamp without time zone" );
/*postgres/universal*/
    TYPE_CONVERSION_MAP.put(  "serial"						, "numeric" );
    TYPE_CONVERSION_MAP.put(  "bigserial"						, "numeric" );
    TYPE_CONVERSION_MAP.put(  "identity"						, "numeric" );
    TYPE_CONVERSION_MAP.put(  "usmallint"						, "numeric" );
    TYPE_CONVERSION_MAP.put(  "utinyint"						, "numeric" );
    TYPE_CONVERSION_MAP.put(  "uinteger"						, "numeric" );
    TYPE_CONVERSION_MAP.put(  "serial"							, "serial" );
    TYPE_CONVERSION_MAP.put(  "bigserial"						, "bigserial" );
    TYPE_CONVERSION_MAP.put(  "integer"							, "numeric" );
    TYPE_CONVERSION_MAP.put(  "integer1"						, "numeric" );
    TYPE_CONVERSION_MAP.put(  "small integer"					, "numeric" );
    TYPE_CONVERSION_MAP.put(  "byteint"							, "numeric" );
    TYPE_CONVERSION_MAP.put(  "int"								, "numeric" );
    TYPE_CONVERSION_MAP.put(  "int1"							, "numeric" );
    TYPE_CONVERSION_MAP.put(  "int2"							, "numeric" );
    TYPE_CONVERSION_MAP.put(  "int4"							, "numeric" );
    TYPE_CONVERSION_MAP.put(  "int8"							, "numeric" );
    TYPE_CONVERSION_MAP.put(  "smallint"						, "numeric" );
    TYPE_CONVERSION_MAP.put(  "smallint unsigned"				, "numeric" );
    TYPE_CONVERSION_MAP.put(  "tinyint"							, "numeric" );
    TYPE_CONVERSION_MAP.put(  "tinyint unsigned"				, "numeric" );
    TYPE_CONVERSION_MAP.put(  "mediumint"						, "numeric" );
    TYPE_CONVERSION_MAP.put(  "bigint"							, "numeric" );
    TYPE_CONVERSION_MAP.put(  "ubigint"							, "numeric" );
    TYPE_CONVERSION_MAP.put(  "bigint unsigned"					, "numeric" );
    TYPE_CONVERSION_MAP.put(  "decimal"							, "numeric" );
    TYPE_CONVERSION_MAP.put(  "large integer"					, "numeric" );
    TYPE_CONVERSION_MAP.put(  "big integer"						, "numeric" );
    TYPE_CONVERSION_MAP.put(  "single-precision floating-point"	, "real" );
    TYPE_CONVERSION_MAP.put(  "double-precision floating-point"	, "double precision" );
    TYPE_CONVERSION_MAP.put(  "numeric"							, "numeric" );
    TYPE_CONVERSION_MAP.put(  "number"							, "numeric" );
    TYPE_CONVERSION_MAP.put(  "float"							, "double precision" );
    TYPE_CONVERSION_MAP.put(  "float4"							, "double precision" );
    TYPE_CONVERSION_MAP.put(  "float8"							, "double precision" );
    TYPE_CONVERSION_MAP.put(  "double"							, "double precision" );
    TYPE_CONVERSION_MAP.put(  "double precision"				, "double precision" );
    TYPE_CONVERSION_MAP.put(  "decimal"							, "numeric" );
    TYPE_CONVERSION_MAP.put(  "real"							, "real" );
	TYPE_CONVERSION_MAP.put(  "char"							, "character varying" );
    TYPE_CONVERSION_MAP.put(  "nchar"							, "character varying" );
    TYPE_CONVERSION_MAP.put(  "smalldatetime"					, "timestamp without time zone" );
    TYPE_CONVERSION_MAP.put(  "int identity"					, "serial" );
    TYPE_CONVERSION_MAP.put(  "image"       					, "bytea" );
    TYPE_CONVERSION_MAP.put(  "binary"       					, "bytea" );
    TYPE_CONVERSION_MAP.put(  "money"       					, "numeric" );
//Bools everywhere and nowhere
    TYPE_CONVERSION_MAP.put(  "bit"								, "boolean" );
    TYPE_CONVERSION_MAP.put(  "bool"							, "boolean" );
    TYPE_CONVERSION_MAP.put(  "boolean"							, "boolean" );
	TYPE_CONVERSION_MAP.put(  "uuid"							, "character varying" );
	//S  A  P
    //                    SAP TYPE    SQL TYPE                 Java type
    TYPE_CONVERSION_MAP.put("P" , "numeric"				); // "id_Double");
    TYPE_CONVERSION_MAP.put("C" , "character varying"	); // "id_String");
    TYPE_CONVERSION_MAP.put("D" , "date"				); // "id_Date");
    TYPE_CONVERSION_MAP.put("F" , "numeric"				); // "id_Double");
    TYPE_CONVERSION_MAP.put("I" , "numeric"				); // "id_Integer");
    TYPE_CONVERSION_MAP.put("b" , "numeric"				); // "id_Double");
    TYPE_CONVERSION_MAP.put("s" , "numeric"				); // "id_Double");
    TYPE_CONVERSION_MAP.put("N" , "character varying"	); // "id_String");
    TYPE_CONVERSION_MAP.put("S" , "character varying"	); // "id_String");
    TYPE_CONVERSION_MAP.put("T" , "time"				); // "id_String");
    TYPE_CONVERSION_MAP.put("X" , "character varying"	); // "id_String");
    TYPE_CONVERSION_MAP.put("g" , "text"				); // "id_String"); ABAP Type ‘G’: Variable length character string
    TYPE_CONVERSION_MAP.put("y" , "text"				); // "id_String"); ABAP Type ‘Y’: Variable length byte array
	TYPE_CONVERSION_MAP_ORA.put(  "bpchar"						, "varchar2" );
    TYPE_CONVERSION_MAP_ORA.put(  "varchar2"					, "varchar2" );
    TYPE_CONVERSION_MAP_ORA.put(  "nvarchar2"					, "varchar2" );
    TYPE_CONVERSION_MAP_ORA.put(  "varchar"						, "varchar2" );
    TYPE_CONVERSION_MAP_ORA.put(  "nvarchar"					, "varchar2" );
    TYPE_CONVERSION_MAP_ORA.put(  "text"						, "varchar2" );
    TYPE_CONVERSION_MAP_ORA.put(  "ntext"						, "varchar2" );
    TYPE_CONVERSION_MAP_ORA.put(  "char varying"				, "varchar2" );
    TYPE_CONVERSION_MAP_ORA.put(  "character varying"			, "varchar2" );
    TYPE_CONVERSION_MAP_ORA.put(  "anydata"						, "varchar2" );
    TYPE_CONVERSION_MAP_ORA.put(  "sys.anydata"					, "varchar2" );
	/* oracle */
    TYPE_CONVERSION_MAP_ORA.put(  "blob"                    	, "blob" );
    TYPE_CONVERSION_MAP_ORA.put(  "bytea"                       , "blob" );
    TYPE_CONVERSION_MAP_ORA.put(  "raw"                         , "blob" );
    TYPE_CONVERSION_MAP_ORA.put(  "long raw"                    , "blob" );
    TYPE_CONVERSION_MAP_ORA.put(  "enum"                        , "blob" );
    TYPE_CONVERSION_MAP_ORA.put(  "set"                         , "blob" );
    TYPE_CONVERSION_MAP_ORA.put(  "char() for bit data"         , "blob" );
    TYPE_CONVERSION_MAP_ORA.put(  "VARCHAR () FOR BIT DATA"     , "blob" );
    TYPE_CONVERSION_MAP_ORA.put(  "varbinary"				    , "blob" );
    TYPE_CONVERSION_MAP_ORA.put(  "longvarbinary"				    , "blob" );
    TYPE_CONVERSION_MAP_ORA.put(  "longvarchar"                 , "clob" );
    TYPE_CONVERSION_MAP_ORA.put(  "urowid"                      , "clob" );
    TYPE_CONVERSION_MAP_ORA.put(  "rowid"                       , "clob" );
    TYPE_CONVERSION_MAP_ORA.put(  "long"                        , "clob/*long*/" );
    TYPE_CONVERSION_MAP_ORA.put(  "clob"                        , "clob" );
    TYPE_CONVERSION_MAP_ORA.put(  "dbclob"                      , "clob" );
    TYPE_CONVERSION_MAP_ORA.put(  "char large object"           , "clob" );
    TYPE_CONVERSION_MAP_ORA.put(  "character large object"      , "clob" );
    TYPE_CONVERSION_MAP_ORA.put(  "text"                        , "clob" );
    /* oracle */
    TYPE_CONVERSION_MAP_ORA.put(  "ansidate"                    , "date" );
    TYPE_CONVERSION_MAP_ORA.put(  "date"                        , "date" );
    TYPE_CONVERSION_MAP_ORA.put(  "datetime"                    , "timestamp" );
    TYPE_CONVERSION_MAP_ORA.put(  "datetime2"                   , "timestamp" );
    TYPE_CONVERSION_MAP_ORA.put(  "timestamp"                   , "timestamp" );
    TYPE_CONVERSION_MAP_ORA.put(  "timestamp with time zone"    , "timestamp with time zone" );
    TYPE_CONVERSION_MAP_ORA.put(  "timestamptz"                 , "timestamp with time zone" );
    TYPE_CONVERSION_MAP_ORA.put(  "time"                        , "timestamp" );
    TYPE_CONVERSION_MAP_ORA.put(  "timestamp without time zone" , "timestamp" );
	/* oracle */
    TYPE_CONVERSION_MAP_ORA.put(  "serial"                       , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "bigserial"                       , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "identity"                       , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "usmallint"                       , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "utinyint"                        , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "uinteger"                        , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "integer"                         , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "integer1"                        , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "small integer"                   , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "byteint"                         , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "int"                             , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "int1"                            , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "int2"                            , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "int4"                            , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "int8"                            , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "smallint"                        , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "smallint unsigned"               , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "tinyint"                         , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "tinyint unsigned"                , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "mediumint"                       , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "bigint"                          , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "ubigint"                          , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "decimal"                         , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "large integer"                   , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "big integer"                     , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "bigint unsigned"                 , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "single-precision floating-point" , "binary_float" );
    TYPE_CONVERSION_MAP_ORA.put(  "double-precision floating-point" , "binary_float" );
    TYPE_CONVERSION_MAP_ORA.put(  "numeric"                         , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "number"                          , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "float"                           , "float" );
    TYPE_CONVERSION_MAP_ORA.put(  "float4"                          , "float" );
    TYPE_CONVERSION_MAP_ORA.put(  "float8"                          , "float" );
    TYPE_CONVERSION_MAP_ORA.put(  "double"                          , "float" );
    TYPE_CONVERSION_MAP_ORA.put(  "double precision"                , "float" );
    TYPE_CONVERSION_MAP_ORA.put(  "decimal"                         , "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "real"                            , "number" );
    /* character types */
    TYPE_CONVERSION_MAP_ORA.put(  "char"						, "varchar2" );
    TYPE_CONVERSION_MAP_ORA.put(  "nchar"						, "nvarchar2" );
	// SQL SERVER TYPES
    TYPE_CONVERSION_MAP_ORA.put(  "smalldatetime"				, "timestamp without time zone" );
    TYPE_CONVERSION_MAP_ORA.put(  "int identity"				, "number" );
    TYPE_CONVERSION_MAP_ORA.put(  "image"       				, "blob" );
    TYPE_CONVERSION_MAP_ORA.put(  "binary"       				, "blob" );
    TYPE_CONVERSION_MAP_ORA.put(  "money"       				, "number" );
 //Bools everywhere and nowhere
    TYPE_CONVERSION_MAP_ORA.put(  "bit"							, "varchar2" );
    TYPE_CONVERSION_MAP_ORA.put(  "bool"						, "varchar2" );
    TYPE_CONVERSION_MAP_ORA.put(  "boolean"						, "varchar2" );
    TYPE_CONVERSION_MAP_ORA.put(  "uuid"						, "varchar2" );
	/*hive*/
    TYPE_CONVERSION_MAP_HIVE.put(  "bpchar"                     , "varchar" );
    TYPE_CONVERSION_MAP_HIVE.put(  "varchar2"                   , "varchar" );
    TYPE_CONVERSION_MAP_HIVE.put(  "nvarchar2"                  , "varchar" );
    TYPE_CONVERSION_MAP_HIVE.put(  "varchar"                    , "varchar" );
    TYPE_CONVERSION_MAP_HIVE.put(  "wvarchar"                   , "varchar" );
    TYPE_CONVERSION_MAP_HIVE.put(  "nvarchar"                   , "varchar" );
    TYPE_CONVERSION_MAP_HIVE.put(  "text"                       , "string" );
    TYPE_CONVERSION_MAP_HIVE.put(  "ntext"                      , "string" );
    TYPE_CONVERSION_MAP_HIVE.put(  "char varying"               , "varchar" );
    TYPE_CONVERSION_MAP_HIVE.put(  "character varying"          , "varchar" );
    TYPE_CONVERSION_MAP_HIVE.put(  "anydata"                    , "varchar" );
    TYPE_CONVERSION_MAP_HIVE.put(  "sys.anydata"                , "varchar" );
/*hive*/
    TYPE_CONVERSION_MAP_HIVE.put(  "blob"                       , "binary" );
    TYPE_CONVERSION_MAP_HIVE.put(  "bytea"                      , "binary" );
    TYPE_CONVERSION_MAP_HIVE.put(  "raw"                        , "binary" );
    TYPE_CONVERSION_MAP_HIVE.put(  "long raw"                   , "binary" );
    TYPE_CONVERSION_MAP_HIVE.put(  "enum"                       , "binary" );
    TYPE_CONVERSION_MAP_HIVE.put(  "set"                        , "binary" );
    TYPE_CONVERSION_MAP_HIVE.put(  "char() for bit data"        , "binary" );
    TYPE_CONVERSION_MAP_HIVE.put(  "VARCHAR () FOR BIT DATA"    , "binary" );
    TYPE_CONVERSION_MAP_HIVE.put(  "varbinary"                  , "binary" );
    TYPE_CONVERSION_MAP_HIVE.put(  "longvarbinary"                  , "binary" );
 /*hive*/
    TYPE_CONVERSION_MAP_HIVE.put(  "urowid"                     , "string" );
    TYPE_CONVERSION_MAP_HIVE.put(  "rowid"                      , "varchar" );
    TYPE_CONVERSION_MAP_HIVE.put(  "long"                       , "string/*long*/" );
    TYPE_CONVERSION_MAP_HIVE.put(  "clob"                       , "string" );
    TYPE_CONVERSION_MAP_HIVE.put(  "char large object"          , "string" );
    TYPE_CONVERSION_MAP_HIVE.put(  "character large object"     , "string" );
    TYPE_CONVERSION_MAP_HIVE.put(  "text"                       , "string" );
/*hive*/
    TYPE_CONVERSION_MAP_HIVE.put(  "ansidate"                   , "timestamp" );
    TYPE_CONVERSION_MAP_HIVE.put(  "date"                       , "timestamp" );
    TYPE_CONVERSION_MAP_HIVE.put(  "datetime"                   , "timestamp" );
    TYPE_CONVERSION_MAP_HIVE.put(  "datetime2"                  , "timestamp" );
    TYPE_CONVERSION_MAP_HIVE.put(  "timestamp"                  , "timestamp" );
    TYPE_CONVERSION_MAP_HIVE.put(  "timestamp with time zone"   , "timestamp" );
    TYPE_CONVERSION_MAP_HIVE.put(  "timestamptz"                , "timestamp" );
    TYPE_CONVERSION_MAP_HIVE.put(  "time"                       , "time" );
    TYPE_CONVERSION_MAP_HIVE.put(  "timestamp without time zone", "timestamp" );
/*hive*/
    TYPE_CONVERSION_MAP_HIVE.put(  "identity"                          , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "serial"                          , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "bigserial"                       , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "integer"                         , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "integer1"                        , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "small integer"                   , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "byteint"                         , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "int"                             , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "int1"                            , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "int2"                            , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "int4"                            , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "int8"                            , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "smallint"                        , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "smallint unsigned"               , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "tinyint"                         , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "mediumint"                       , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "bigint"                          , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "ubigint"                          , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "decimal"                         , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "large integer"                   , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "big integer"                     , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "single-precision floating-point" , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "double-precision floating-point" , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "numeric"                         , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "number"                          , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "float"                           , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "float4"                          , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "float8"                          , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "double"                          , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "double precision"                , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "decimal"                         , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "real"                            , "decimal" );
     TYPE_CONVERSION_MAP_HIVE.put(  "char"                       , "varchar" );
    TYPE_CONVERSION_MAP_HIVE.put(  "nchar"                      , "varchar" );
     // SQL SERVER TYPES
    TYPE_CONVERSION_MAP_HIVE.put(  "smalldatetime"              , "timestamp" );
    TYPE_CONVERSION_MAP_HIVE.put(  "int identity"               , "decimal" );
    TYPE_CONVERSION_MAP_HIVE.put(  "image"                      , "binary" );
    TYPE_CONVERSION_MAP_HIVE.put(  "binary"                     , "binary" );
    TYPE_CONVERSION_MAP_HIVE.put(  "money"                      , "numeric" );
//Bools everywhere and nowhere
    TYPE_CONVERSION_MAP_HIVE.put(  "bit"                        , "boolean" );
    TYPE_CONVERSION_MAP_HIVE.put(  "bool"                       , "boolean" );
    TYPE_CONVERSION_MAP_HIVE.put(  "boolean"                    , "boolean" );
  TYPE_CONVERSION_MAP_HIVE.put(  "uuid"                            , "varchar" );
  
    
    
    
    
    
    
    
    
    
    RESERVED_KEYWORDS = new java.util.ArrayList<String>();
    RESERVED_KEYWORDS.add(  "desc"			);
    RESERVED_KEYWORDS.add(  "asc"			);
    RESERVED_KEYWORDS.add(  "where"			);
    RESERVED_KEYWORDS.add(  "row"			);
    RESERVED_KEYWORDS.add(  "char"			);
    RESERVED_KEYWORDS.add(  "not"			);
    RESERVED_KEYWORDS.add(  "group"			);
    RESERVED_KEYWORDS.add(  "view"			);
    RESERVED_KEYWORDS.add(  "connect"		);
    RESERVED_KEYWORDS.add(  "constraint"	);
    RESERVED_KEYWORDS.add(  "constraints"	);
    RESERVED_KEYWORDS.add(  "continue"		);
    RESERVED_KEYWORDS.add(  "create"		);
    RESERVED_KEYWORDS.add(  "count"			);
    RESERVED_KEYWORDS.add(  "cross"			);
    RESERVED_KEYWORDS.add(  "current"		);
    RESERVED_KEYWORDS.add(  "date"			);
    RESERVED_KEYWORDS.add(  "degree"		);
    RESERVED_KEYWORDS.add(  "delete"		);
    RESERVED_KEYWORDS.add(  "describe"		);
    RESERVED_KEYWORDS.add(  "distinct"		);
    RESERVED_KEYWORDS.add(  "domain"		);
    RESERVED_KEYWORDS.add(  "double"		);
    RESERVED_KEYWORDS.add(  "drop"			);
    RESERVED_KEYWORDS.add(  "else"			);
    RESERVED_KEYWORDS.add(  "end"			);
    RESERVED_KEYWORDS.add(  "except"		);
    RESERVED_KEYWORDS.add(  "escape"		);
    RESERVED_KEYWORDS.add(  "exception"		);
    RESERVED_KEYWORDS.add(  "exists"		);
    RESERVED_KEYWORDS.add(  "external"		);
    RESERVED_KEYWORDS.add(  "extract"		);
    RESERVED_KEYWORDS.add(  "false"			);
    RESERVED_KEYWORDS.add(  "fetch"			);
    RESERVED_KEYWORDS.add(  "float"			);
    RESERVED_KEYWORDS.add(  "first"			);
    RESERVED_KEYWORDS.add(  "force"			);
    RESERVED_KEYWORDS.add(  "for"			);
    RESERVED_KEYWORDS.add(  "user"			);
    RESERVED_KEYWORDS.add(  "filter"		);
    RESERVED_KEYWORDS.add(  "deferrable"	);
    RESERVED_KEYWORDS.add(  "distributed"	);
    RESERVED_KEYWORDS.add(  "partition"		);
    RESERVED_KEYWORDS.add(  "offset"		);
    RESERVED_KEYWORDS.add(  "freeze"		);
    RESERVED_KEYWORDS.add(  "current_date"  );
    RESERVED_KEYWORDS.add(  "current_user"  );
    RESERVED_KEYWORDS.add(  "range"			);
    RESERVED_KEYWORDS.add(  "limit"			);
    RESERVED_KEYWORDS.add(  "offset"		);
    RESERVED_KEYWORDS.add(  "exclude"		);
    RESERVED_KEYWORDS.add(  "character"		);
    RESERVED_KEYWORDS.add(  "new"			);
    RESERVED_KEYWORDS.add(  "ctid"			);
    RESERVED_KEYWORDS.add(  "xmin"			);
    
    SYSTEM_TYPE_MAP = new java.util.HashMap<String, Integer>();
    SYSTEM_TYPE_MAP.put("GP", 1);
    SYSTEM_TYPE_MAP.put("GREENPLUM", 1);
    SYSTEM_TYPE_MAP.put("HAWQ", 1);
        
    SYSTEM_TYPE_MAP.put("REDSHIFT", 2);
    
    SYSTEM_TYPE_MAP.put("POSTGRESQL", 	4);    
    SYSTEM_TYPE_MAP.put("POSTGRES",		4);    
    SYSTEM_TYPE_MAP.put("POSTGRE", 		4);
    
    SYSTEM_TYPE_MAP.put("ORACLE_SID", 14);
    
    SYSTEM_TYPE_MAP.put("ORACLE_SERVICE", 18);
    SYSTEM_TYPE_MAP.put("ORACLE_SERVICE_NAME", 18);
    SYSTEM_TYPE_MAP.put("ORACLE_SERVICENAME", 18);
    SYSTEM_TYPE_MAP.put("ORACLE", 18);
    
    SYSTEM_TYPE_MAP.put("HIVE", 22);
  
  }
  
  /**
   * This function allows us to handle different target systems in a generic way.
   * Multiple inputs can yield in the same target.
   * @param System_Type like: Greenplum, GP, Postgre, HAWQ, Redshift, Oracle, etc.
   * @return an integer that must be used in all the jobs, to decide the path
   */
  	public static int getSystemType(String systemType) {
  		systemType = systemType.toUpperCase();
  		if(SYSTEM_TYPE_MAP.get(systemType) != null) {
  			return SYSTEM_TYPE_MAP.get(systemType);
  		} else {  //for backward compatibility!
//  			System.err.println("\nUnknown system type:" + systemType);
  			return 1;
  		}
  	}

    /**
     * getLengthAndPrecision: return the straight expression for a CreateTable for LengthAndPrecision
     * {talendTypes} String
     * {Category} User Defined
     * {param} string(length, precision) input: the length and precision which need to be combined
     * {example} getLengthAndPrecision(length, precision) # return different output based on the data content
     */
    public static String getLengthAndPrecision(String typeName, int length, int precision) {
            
    	if (typeName.equals("text")
    		/*|| (typeName.equals("character varying") && precision > 255)*/
    		|| typeName.equals ("timestamp with time zone")
    		|| typeName.equals ("timestamp without time zone")
    		|| typeName.equals ("date")
    		|| typeName.equals ("time")
    		|| typeName.equals ("float")
    		|| typeName.equals ("bytea")
    		|| typeName.equals ("double")
    		|| typeName.equals ("double precision")
    		|| typeName.equals ("single-precision floating-point")
    		|| typeName.equals ("double-precision floating-point")
    		|| typeName.equals ("boolean")
    	 	|| typeName.equals ("serial")){
    		//System.out.println("Found the bugger!");
    		return "";
    	}   	
	    if (length > 0  && precision > 0)
	    	return "("+length+","+precision+")";
	    else if (length > 0 && precision == 0)
	    	return "("+length+")";
	    else 
	    	return "";
    }

    public static String fixTooShortColumn(String typeName, int length) {
        
    	if ((typeName.equals("character varying") && length > 400)){
    		return "text";
    	}
    	else {
    		return typeName;
    	}
    		
	}
    /**
     * Converts SAP Types To Greenplum Data Types
     */
    public static String mapSAPToGreenplumTypes(String sapTypeName) {
     
     String forreturn = TYPE_CONEVERsION_MAP.get(sapTypeName);
     if(forreturn == null && debugModeOn) {
       System.out.println("Non-Trapped SAP Type Name: " + sapTypeName + " || Returned Text Type As Catch All");
     }
     return forreturn == null ? "text" : forreturn;
     }
    
    /**
     * Converts DB Types To Greenplum Data Types
     */
    public static String mapToGreenplumTypes(String typeName) {
     
     String forreturn = TYPE_CONEVERsION_MAP.get(typeName.toLowerCase());
     if(forreturn == null && debugModeOn) {
       System.out.println("Non-Trapped Type Name: " + typeName + " || Returned Text Type As Catch All");
     }
     System.out.println("hello");
     return forreturn == null ? "text" : forreturn;
     }
    
    
    public static String mapMSSQLToMysqlTypes(String typeName, int len, int precision) {
        
        String forreturn = TYPE_CONEVERsION_MAP.get(typeName.toLowerCase());
       // System.out.println("typeName: "+typeName+" mapped to: "+forreturn+ " length: "+len+" precision: "+precision);
        if (forreturn != null){
	        if (((len > 255) || ( precision > 255 )) && forreturn.equals("character varying")){
	        		//System.out.pritln(" MYSQL EXCEPTION length: character varying "+len+ " mapped to: text");	
	        		return "text";	        	
	        }   		
	        return forreturn;
        }
        else{
	        if(debugModeOn) {
	        	System.out.println("Non-Trapped Type Name: " + typeName + " || Returned Text Type As Catch All");
	        }
        	return "text";
        }
     }
    
    public static String mapMSSQLToPOSTGREsqlTypes(String typeName, int len, int precision, boolean TimestampToText) {
        String forreturn = TYPE_CONEVERsION_MAP.get(typeName.toLowerCase());
       //System.out.println("typeName: "+typeName+" mapped to: "+forreturn+ " length: "+len+" precision: "+precision);
        if (forreturn != null){
        	if (forreturn.equals("timestamp without time zone") && TimestampToText){
	        	   return "text";
        	}
        	if (forreturn.equals("timestamp")){
	        	   return "text";
     	}
	        if (((len > 255) || ( precision > 255 )) && forreturn.equals("character varying")){
	        		return "text";	        	
	        } 
	        return forreturn;
        }
        else{
	        if(debugModeOn) {
	        	System.out.println("Non-Trapped Type Name: " + typeName + " || Returned Text Type As Catch All");
	        }
        	return "text";
        }
     }

   	
    
    /**
     * fixBadTableNames: Repairs both the column names and table names.
     * Removes special characters such as @, # and $ from text where:
     * # = _1
     * @ = _2
     * $ = _3
     * Special Words = _4
     * @author 212342594 - Matthew Green
     * {Category} GEroutine
     * {talendType} String
     * {param} 
     * {example} fixBadTableNames(String tableName)
     */
    public static String fixBadTableNames(String tableName) {
        /*if(tableName.contains("(") || tableName.contains(")") || tableName.contains("*") ||
        Character.isDigit(tableName.charAt(0)) || RESERVED_KEYWORDS.contains(tableName.toLowerCase())
        || tableName.contains("#") || tableName.contains("@") || tableName.contains("$")
        || tableName.contains("/") || tableName.contains(" "))*/
    	if(RESERVED_KEYWORDS.contains(tableName.toLowerCase()))
    		return "\"" + tableName.toLowerCase() + "_\"";
        else 
        	return "\"" + tableName.toLowerCase() + "\"";
    	
       }
    
    /**
     * {Category} GEroutine
     * {talendType} String
     * {param} 
     * {example} fixBadTableNames(String tableName, Boolean useQuote, String quoteChar)
     */
    public static String fixBadTableNames(String tableName, Boolean useQuote, String quoteChar) {
    	if (!useQuote){
    		return tableName.toLowerCase();
    	} else 
    		if(RESERVED_KEYWORDS.contains(tableName.toLowerCase()))
        		return quoteChar + tableName.toLowerCase() + "_" + quoteChar;
            else 
            	return quoteChar + tableName.toLowerCase() + quoteChar;
//    		return quoteChar + tableName.toLowerCase() + quoteChar;
    	
        /*if( useQuote && (tableName.contains(".") || tableName.contains("(") || tableName.contains(")") || tableName.contains("#") || tableName.contains("@") || tableName.contains("$") || tableName.contains("*") ||
        		tableName.contains(":") || tableName.contains(" ") || tableName.contains("/") || Character.isDigit(tableName.charAt(0)) || RESERVED_KEYWORDS.contains(tableName.toLowerCase())))
            return quoteChar + tableName.toLowerCase() + quoteChar;
        else return tableName.toLowerCase();*/
       }
    
    /**
     * revertBadTableNames: Resets the bad table names to their
     * original values example: AAPL@ would become AAPL_2 but this function 
     * resets AAPL_2 back to the former AAPL@. Use this function when querying 
     * the existing data source to ensure the lookup does not fail. Does not 
     * revert column names.
     * Resets special characters such as @, # and $ from text where:
     * # = _1
     * @ = _2
     * $ = _3
     * @author 212342594 - Matthew Green
     */
    public static String revertBadTableNames(String tableName) {
      return tableName;
    }
    
    /**
     * {Category} GEroutine
     * {talendType} String
     * {param} 
     * {example} maskString(String inputStr)
     */
    public static String maskString(String inputStr) {  	
    	return maskString(inputStr, 2, 3);
    }
    
    /**
     * {Category} GEroutine
     * {talendType} String
     * {param} 
     * {example} maskString(String inputStr, int param1, int param2)
     */
    public static String maskString(String inputStr, int param1, int param2) {
    	StringBuilder sb = new StringBuilder();
    	for(int i=0 ; i<inputStr.length() ; i++ ) {
    	   if(i%param1 == 0 || i%param2 == 0) {
    		   sb.append("#");
    	    } else {
    	       sb.append(inputStr.charAt(i));
    	    }
    	}
    	return sb.toString();
     }
    
    /**
     * {Category} SQL
     * {talendType} String
     * {param} 
     * {example} sqlDropTable(String schema, String schemaPrefix, String tableName)
     */
    public static String sqlDropTable(String schema, String schemaPrefix, String tableName) {
    	return "DROP TABLE IF EXISTS " + sqlGetSchema(schema,schemaPrefix) + "." + tableName;    	
    }
    
    /**
     * {Category} SQL
     * {talendType} String
     * {param} 
     * {example} sqlCreateTable(String schema, String schemaPrefix, String tableName,String columnList, String additionalColumns)
     */   
    public static String sqlCreateTable(String schema, String schemaPrefix, String tableName,String columnList, String additionalColumns) {
    	String cols = columnList;
    	if(additionalColumns.length()>0){
    		if(cols.endsWith(",")){
    			if(additionalColumns.startsWith(",") ){
    				cols = cols.substring(0,cols.length()-1);    			
    			}
    			cols += additionalColumns;
    		} else {
    			if(false == additionalColumns.startsWith(",") ){
    				cols += ",";
    			}
    			cols += additionalColumns;
    		}
    	}
    	return "CREATE TABLE " + sqlGetSchema(schema,schemaPrefix) + "." + tableName +" ( " + cols +" )"+
    		" WITH (appendonly=true, orientation=column, compresstype=quicklz)";
    }
    
    /**
     * {Category} SQL
     * {talendType} String
     * {param} 
     * {example} sqlDropSchema(String schema, String schemaPrefix)
     */
    public static String sqlDropSchema(String schema, String schemaPrefix) {
    	return "DROP SCHEMA IF EXISTS " +sqlGetSchema(schema,schemaPrefix) + " CASCADE";
    }
    
    /**
     * {Category} SQL
     * {talendType} String
     * {param} 
     * {example} sqlCreateSchema(String schema, String schemaPrefix, String user)
     */
    public static String sqlCreateSchema(String schema, String schemaPrefix, String user) {
    	return "CREATE SCHEMA " +sqlGetSchema(schema,schemaPrefix)+ " AUTHORIZATION " +user + ";" + "\n" + 
    	"GRANT ALL ON SCHEMA " + sqlGetSchema(schema,schemaPrefix)+ " TO " + user + ";" + "\n" + 
    	"GRANT ALL ON SCHEMA " + sqlGetSchema(schema,schemaPrefix)+ " TO public;";
    }
    
    /**
     * {Category} SQL
     * {talendType} String
     * {param} 
     * {example} sqlGetSchema(String schema, String schemaPrefix)
     */
    public static String sqlGetSchema(String schema, String schemaPrefix) {    	
    	return fixBadTableNames(schemaPrefix + schema.toLowerCase());
    }
       
    
    
    
    ///////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////
    ////////////D   E    P     R      E     C     A     T    E   D/////////////////
    ///////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////
    
    
    /**
     * Converts MySQL Types To Greenplum Data Types
     */
    public static String mapMySQLToGreenplumTypes(String mySQLTypeName) {
     
     String forreturn = TYPE_CONEVERsION_MAP.get(mySQLTypeName.toLowerCase());
     if(forreturn == null && debugModeOn) {
       System.out.println("Non-Trapped MySQL Type Name: " + mySQLTypeName + " || Returned Text Type As Catch All");
     }
     return forreturn == null ? "text" : forreturn;
     }
    
    /**
     * Pseudo Code to fix compilation issue in 7.2
     
    public static String mapToTargetTypes(String mySQLTypeName, String mySQLSource) {
     
     String forreturn = null;
     return forreturn ;
     }*/
    
    public static String mapToTargetTypes(String typeName, String systemType) {
        typeName = (typeName== null) ? "null" : typeName;
        String forreturn = null;
        if (getSystemType(systemType) < 10 )
    		{
    			forreturn = TYPE_CONVERSION_MAP.get(typeName.toLowerCase());
    		}
        
    	if (getSystemType(systemType) > 10 && //Oracle_SID 
        		getSystemType(systemType) < 20) //Oracle_Service
    		{
    			forreturn = TYPE_CONVERSION_MAP_ORA.get(typeName.toLowerCase());
    		}
    	if (getSystemType(systemType) > 20 ) // HIVE
    		{
    			forreturn = TYPE_CONVERSION_MAP_HIVE.get(typeName.toLowerCase());
    		}
    	
        if(forreturn == null && debugModeOn) {
            System.out.println("Non-Trapped Type Name: " + typeName + " || Returned Text Type As Catch All");
            if(getSystemType(systemType) > 20 ){
            	forreturn = "string";
            } else 
            	forreturn = "text";
          }        
        return forreturn;
    }
    
    
    
    /**
     * Converts Teradata Types To Greenplum Data Types
     */
    public static String mapTeradataToGreenplumTypes(String mySQLTypeName) {
     
     String forreturn = TYPE_CONEVERsION_MAP.get(mySQLTypeName.toLowerCase());
     if(forreturn == null && debugModeOn) {
       System.out.println("Non-Trapped Teradata Type Name: " + mySQLTypeName + " || Returned Text Type As Catch All");
     }
     if(forreturn == "character") {
    	 forreturn = "character varying";
       }
     return forreturn == null ? "text" : forreturn;
     }
    
    
    
    
    /**
     * Converts Oracle Types To Greenplum Data Types
     */
    public static String mapOracleToGreenplumTypes(String oracleTypeName) {
        
     //"VARCHAR2".equals(row7.ColumnTypeName) ? "character varying" : row7.ColumnTypeName 
    	//System.out.println("oracleTypeName"+oracleTypeName);
    	String forreturn = TYPE_CONEVERsION_MAP.get(oracleTypeName.toLowerCase());
    	try
    	{
    
	    if(forreturn.equals("date")){
	    	forreturn = "timestamp without time zone";
	    }
	    if(forreturn.equals("timestamp with time zone")){
	    	forreturn = "timestamp with time zone";
	    }
	     if(forreturn == null && debugModeOn) {
	       System.out.println("Non-Trapped Oracle Type Name: " + oracleTypeName + " || Returned Text Type As Catch All");
	     }
     
    	}
    	catch(Exception e)
    	{
    		System.out.println("Non-Trapped Oracle Type Name: " + oracleTypeName + " || Returned Text Type As Catch All");	
    	}
    	return forreturn == null ? "text" : forreturn;
     }
    
    
    public static String mapOracleToHiveTypes(String TypeName) {
        
        //"VARCHAR2".equals(row7.ColumnTypeName) ? "character varying" : row7.ColumnTypeName 
       String forreturn = TYPE_CONEVERsION_MAP_HDFS.get(TypeName.toLowerCase());
       if(forreturn.equals("date")){
       	forreturn = "STRING";
       }
        if(forreturn == null && debugModeOn) {
          System.out.println("Non-Trapped Oracle Type Name: " + TypeName + " || Returned Text Type As Catch All");
        }
        return forreturn == null ? "STRING" : forreturn;
        }
    
    
    
    
    
    /**
     * Converts SQLServer Types To Greenplum Data Types
     */
    public static String mapSQLServerToGreenplumTypes(String sqlTypeName,int len,int precision) {
        
        //"VARCHAR2".equals(row7.ColumnTypeName) ? "character varying" : row7.ColumnTypeName 
    	log.debug("mapSQLServerToGreenplumTypes - " + "Started.");
    	log.debug("mapSQLServerToGreenplumTypes parameters -  type:" + sqlTypeName+" len:"+((Integer)len).toString()+" precision:"+((Integer)precision).toString());
       String forreturn = TYPE_CONEVERsION_MAP.get(sqlTypeName.toLowerCase().replace(" identity", ""));
       if (forreturn.equals("timestamp without time zone")){
     	//   return "text";
   		}
	   	if (sqlTypeName.toLowerCase().equals("timestamp")){
	   		log.debug("mapSQLServerToGreenplumTypes - " + "Result: "+"text");
	     	   return "text";
	   	}
       if (((len > 255) || ( precision > 255 )) && forreturn.equals("character varying")){
    	   log.debug("mapSQLServerToGreenplumTypes - " + "Result: "+"text");
   		return "text";	        	
       } 
        if(forreturn == null && debugModeOn) {
        	log.debug("Non-Trapped SQLServer Type Name: " + sqlTypeName + " || Returned Text Type As Catch All");
        }
        log.debug("mapSQLServerToGreenplumTypes - " + "Result: "+forreturn == null ? "text" : forreturn);
        return forreturn == null ? "text" : forreturn;
        }      
    
    /**
     * Converts AS400 Types To Greenplum Data Types
     */
    public static String mapAS400ToGreenplumTypes(String as400TypeName) {
     
     String forreturn = TYPE_CONEVERsION_MAP.get(as400TypeName.toLowerCase());
     if(forreturn == null && debugModeOn) {
       System.out.println("Non-Trapped AS400 Type Name: " + as400TypeName + " || Returned Text Type As Catch All");
     }
     return forreturn == null ? "text" : forreturn;
     }
    
    public static String getFileNameForTableName(String tableName) {
  		String forReturn = tableName.replace("\"","").replace("/","__slash__").replace("\\","__bslash__").replace("#","__hash__").replace("$","__dollar__");
  		forReturn = forReturn.replace(" ","_").replace(",","__comma__").replace(".","__colon__").replace(";","__semicolon__").replace("'","__apostrophe__");
  		forReturn = forReturn.replace("(","__40__").replace(")","__41__").replace("&","__38__").replace("£","__pound__").replace("§","__paragraph__");
  		return forReturn;
  	}
}
